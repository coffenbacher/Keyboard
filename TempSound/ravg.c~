/* Remote average client code.
 * Taken from http://www.linuxjournal.com/articles/lj/0042/2204/2204l4.html
 */
#include "avg.h"
#include <stdlib.h>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>

#include <pulse/simple.h>
#include <pulse/error.h>
#include <pulse/gccmacro.h>

#define BUFSIZE 1024

pa_simple *s_read = NULL;

void
serverprog_1( char* host, int argc, char *argv[])
{
        CLIENT *clnt_control;
        CLIENT *clnt_server;
        control_data  control_1_arg;
        input_data  server_1_arg;
        int  *result_1, *result_2;
	char buffer[1024];
	char *dp, f;
        char *endptr;
	int i;
	uint8_t buf[BUFSIZE];
	int error;

        control_1_arg.flag = 1;
        clnt_control = clnt_create(host, CONTROLPROG, CONTROLVERS, "udp");
        if (clnt_control == NULL) {
                clnt_pcreateerror(host);
                exit(1);
        }
        result_1 = control_1(&control_1_arg, clnt_control);
	if (result_1 == NULL) {
                clnt_perror(clnt_control, "control call failed:");
        }
        printf("result_1 = %i\n", *result_1);

        server_1_arg.input_data.input_data_val = (char*) malloc(1024*sizeof(char));

	startReadServer();



	for (i = 0; i < 1000; i++) {
        	printf("i=%i\n", i);
	        /* Record some data ... */
		 if (pa_simple_read(s_read, buf, sizeof(buf), &error) < 0) {
        	    fprintf(stderr, __FILE__": pa_simple_read() failed: %s\n", pa_strerror(error));
		    }
	
		 dp = server_1_arg.input_data.input_data_val;
        for ( i = 0; i < 1024; i++) {
		f = buf[i];
                *dp = f;
                dp++;
        }
        clnt_server = clnt_create(host, SERVERPROG, SERVERVERS, "udp");
        if (clnt_server == NULL) {
                clnt_pcreateerror(host);
                exit(1);
        }
        result_1 = server_1(&server_1_arg, clnt_server);
        if (result_2 == NULL) {
                clnt_perror(clnt_control, "server call failed:");
        }
	 }
	
	
        dp = server_1_arg.input_data.input_data_val;
        for ( i = 1; i <= (1024); i++) {
		f = (char)i;
                *dp = f;
                dp++;
        }
        clnt_server = clnt_create(host, SERVERPROG, SERVERVERS, "udp");
        if (clnt_server == NULL) {
                clnt_pcreateerror(host);
                exit(1);
        }
        result_1 = server_1(&server_1_arg, clnt_server);
        if (result_2 == NULL) {
                clnt_perror(clnt_control, "server call failed:");
        }


        clnt_destroy( clnt_server );

        printf("result_2 = %i\n", *result_2);
}

int startReadServer()
{
    static const pa_sample_spec ss = {
        .format = PA_SAMPLE_S16LE,
        .rate = 44100,
        .channels = 2
    };
    int ret = 1;
    int error;
    int i,j;

    /* Create the recording stream */
    if (!(s_read = pa_simple_new(NULL, "read_server", PA_STREAM_RECORD, NULL, "record", &ss, NULL, NULL, &error))) {
        fprintf(stderr, __FILE__": pa_simple_new() failed: %s\n", pa_strerror(error));
        goto finish;
    }
finish:
    return ret;
}

int stopReadServer()
{
    if (s_read)
        pa_simple_free(s_read);
}

main( int argc, char* argv[] )
{
        char *host;

        if (argc < 3) {
                printf("usage: %s server_host value ...\n",
                        argv[0]);
                exit(1);
        }
        if (argc > MAXBUFFERSIZE + 2) {
                printf("Two many input values\n");
                exit(2);
        }
        host = argv[1];
        serverprog_1(host, argc, argv);
}
